---
title: "FinalProject_2.0"
author: "Sowmiyaa Sridharan"
date: "April 8, 2017"
output: word_document
---

```{r setup, include=FALSE}
processed_fake <- read.csv("/Users/setaresarachi/Desktop/INFSCI 2160/DataMiningFinalProject/preprocessed_fake.csv")
#Removing uuid and default 'x' column
processed_fake<- processed_fake[,c(-1,-3)]

#bs_count<-data.frame(table(processed_fake$type))
#colnames(processed_fake)
#k_means_data <- processed_fake[,c(3,6,7,8,9,10,11,12,13,14,16)]
#getting error
#k_means <- kmeans(k_means_data, centers = 9, nstart = 10)
#library(cluster)
#Hierachial
#Complete
#complete_unemp <- agnes(k_means_data, diss = FALSE, metric = "euclidean", method = "complete")
#plot(complete_unemp, which.plots = 2)
```

```{r PreProcessing}
#Converting domain_rank 'NA' to zero(0)
processed_fake$author <- as.character(processed_fake$author)
processed_fake$title <- as.character(processed_fake$title)
processed_fake$crawled <- as.character(processed_fake$crawled)
processed_fake$site_url <- as.character(processed_fake$site_url)

processed_fake$domain_rank[which(is.na(processed_fake$domain_rank))] <- 0

df_data <- processed_fake[,c(3,6,7,8,9,10,11,12,13,14,15,16)]
df_data <- df_data[,c(-1,-2)]

df_data$domain_rank <- as.numeric(df_data$domain_rank)
  df_data$replies_count <- as.numeric((df_data$replies_count))
  df_data$participants_count <- as.numeric((df_data$participants_count))
  df_data$comments <- as.numeric((df_data$comments))
  df_data$likes<- as.numeric((df_data$likes))
  df_data$shares <- as.numeric((df_data$shares))
```
  
```{r MultinomReg}  
library(nnet)
model_logit<-multinom(formula= type ~.,data = df_data)
```

```{r RandomForest}
library(randomForest)
rf_model <- randomForest(formula = type ~., data = df_data,ntree=100)
importance(rf_model)
str(df_data)
```

```{r kFoldRandomForest}
library(randomForest)
library(MASS) 
library(tree)
library(party)
decisionTree_matr <- as.matrix(df_data)

```

```{r 1Vs1_bait_satire}
table(df_data$type)
bait_satire <- df_data[which(df_data$type %in% c("bait", "satire")),]
bait_satire$type <- as.character(bait_satire$type)
#bait_data$type[-which(bait_data$type %in% "bait")] <- "not_bait"
table(bait_satire$type)
bait_satire$type[which(bait_satire$type %in% "bait")] <- 0
bait_satire$type[which(bait_satire$type %in% "satire")] <- 1
bait_satire$type <- as.factor(bait_satire$type)
```

```{r ModelMatrix}
model_matrix <- function(data_combination){
#Model Matrix
model.mat<-model.matrix(data_combination$type~.,data=data_combination)[,-1]
model.mat[1:3, ]
model.mat <- as.data.frame(model.mat) #converting into data frame
model.mat$type <- data_combination$type 
return(model.mat)
}
```

```{r test}
model.mat<- model_matrix(bait_satire)
logit_result <- logit(bait_satire)

```

```{r logit function}
lg_function <- function(training,testing){
   lg <- glm(type ~ .,data = training,family = "binomial")
   pred <- predict(lg,newdata=testing,type="response")
   return(pred)
}
```

```{r Logit}
logit <- function(data_combination){
model.mat<-model.matrix(data_combination$type~.,data=data_combination)[,-1]
model.mat[1:3, ]
model.mat <- as.data.frame(model.mat) #converting into data frame
model.mat$type <- data_combination$type 

# 10 fold cross validation for logit
for (i in 1:nrow(model.mat))
  model.mat$group[i]=(i%%10)
  result_act  = dim(1)#result_pred = dim(1)
  result_noF_act = dim(1)
  
    for (i in c(0:9)) 
      {
      training=((model.mat[model.mat$group != i, c(1:38)]))  ## traindata 
      testing=((model.mat[model.mat$group == i, c(1:38)]))  ## testdata
      pred <- lg_function(training, testing)
      dat <- data.frame(Actual = model.mat$type[model.mat$group == i], Predicted = pred)
      btest=floor(pred+0.5) 
      dat_floored <- data.frame(Actual = model.mat$type[model.mat$group == i], Predicted = btest)
      result_noF_act=rbind(result_noF_act,dat)
      result_act=rbind(result_act,dat_floored)
      #return(result_act)
    }
      conf.mat <- table(model.mat$type,result_act$Predicted)
      names(attributes(conf.mat)$dimnames) <- c("Actual","Predicted")
      #Error
      error <- (conf.mat[2,1]+conf.mat[1,2])/nrow(model.mat)
      #Accuracy
      accuracy <- (conf.mat[1,1]+conf.mat[2,2])/nrow(model.mat)
      #Precision and Recall
      precision <- (conf.mat[1,1]) / (conf.mat[1,1]+conf.mat[2,1])
      recall <- (conf.mat[1,1]) / (conf.mat[1,1]+ conf.mat[1,2]) 
      #F-score
      f_score<- (2* precision*recall)/ (precision+recall)
      # AUC
      library(pROC)
      ROC <- roc(dat$Actual, dat$Predicted)
      #plot(ROC, col = "blue")
      AUC <- auc(ROC)
      #For ROCR Plot
      #suppressWarnings( library(ROCR))
      #rocr_lg <- prediction(result_noF_act$Predicted, model.mat$type)
      #str(rocr_lg)
      #roc_lg <- performance(rocr_lg, "sens", "fpr")
      #str(roc_lg)
      #plot(roc_lg)
      output <- c(accuracy,error,precision,recall,f_score,AUC)
      #Final Table of all values
      final_table <- data.frame(Accuracy = accuracy,Error = error, Precision = precision, Recall = recall,F_Score =          f_score, AUC = AUC )
      return(final_table)
  
}

head(result_act)
```



